## Задание №1. Алгоритмы балансировки нагрузки


**Алгоритм балансировки нагрузки** – это набор правил, которым следует балансировщик нагрузки для определения наилучшего сервера для каждого из различных клиентских запросов. 

**Общие принципы**  
Выбирая или разрабатывая алгоритм, нужно придерживаться трех принципов:

- *Справедливость*. Каждый запрос должен обрабатываться. Нельзя допустить, чтобы запросы стояли в очереди друг за другом. Поэтому перед разработкой алгоритма балансировки нужно проверить нагрузку на сервер в динамике, чтобы знать, к каким скачкам нужно готовиться.
- *Рациональность*. Все серверы из пула должны работать. Желательно — всегда и на полную мощность. Это не всегда достижимо, и задача алгоритма — распределить нагрузку максимально равномерно.
- *Скорость*. Хороший балансирующий алгоритм обеспечивает быструю обработку запросов.

### Round Robin (циклический перебор)
Round Robin, или алгоритм кругового обслуживания, представляет собой перебор по круговому циклу: первый запрос передаётся одному серверу, затем следующий запрос передаётся другому и так до достижения последнего сервера, а затем всё начинается сначала.
Хорошо работает, когда серверы имеют одинаковую мощность, а запросы одинаково затратны.
Главная проблема этого подхода — нерациональное распределение ресурсов. Даже если все машины обладают примерно одинаковыми характеристиками, реальная нагрузка будет сильно различаться в пуле.
Также при балансировке по алгоритму Round Robin совершенно не учитывается загруженность того или иного сервера в составе кластера, поэтому перегруженный узел все равно будет получать запросы. Ни о какой справедливости, эффективности и предсказуемости в таком случае не может быть и речи.

### Weighted Round Robin (взвешенный циклический перебор)
Этот алгоритм аналогичен предыдущему, но он дополнительно берет во внимание производительность сервера. Чем мощнее машина, тем больше запросов она обрабатывает. Это не идеальный подход, но он значительно лучше обычного Round Robin.

Еще один недостаток алгоритма Round Robin:в нём совершенно не учитывается количество активных на данный момент подключений.

### Least Connections (Наименьшее количество соединений)
Суть этого алгоритма проста: каждый последующий запрос направляется на сервер с наименьшим количеством поддерживаемых подключений. Least Connections — это изящное и эффективное решение, которое позволяет адекватно распределять нагрузку по серверам с приблизительно одинаковыми параметрами.
Уязвимое место — необходимость балансировки между несколькими Frontend-серверами. Когда пользователь устанавливает соединение с Frontend-сервером, все запросы будут отправляться именно на него. При соблюдении алгоритма Least connections другой Frontend-сервер может быть менее нагружен, и пользователь подключится к нему — ему придется заново авторизоваться.

### Destination Hash Scheduling   
Алгоритм Destination Hash Scheduling был создан для работы с кластером кэширующих прокси-серверов, но он часто используется и в других случаях. В этом алгоритме сервер, обрабатывающий запрос, выбирается из статической таблицы по IP-адресу получателя. 
Если нагрузка от разных источников неравномерно распределена, некоторые серверы могут быть перегружены, в то время как другие недостаточно загружены. Это может привести к  неэффективному использованию ресурсов.

### Source Hash Scheduling
Алгоритм Source Hash Scheduling основывается на тех же самых принципах, что и Destination Hash Scheduling, только сервер, который будет обрабатывать запрос, выбирается из таблицы по IP-адресу отправителя.
Поскольку запросы от одного источника могут быть направлены на разные серверы, сохранение состояния сеанса может быть сложным и потребовать дополнительной логики и механизмов.

### Sticky Sessions
В этом алгоритме запросы распределяются в зависимости от IP-адреса пользователя. Sticky Sessions предполагает, что обращения от одного клиента будут направляться на один и тот же сервер, а не скакать в пуле. Клиент сменит сервер только в том случае, если ранее использовавшийся больше не доступен.
Применение этого метода сопряжено с некоторыми проблемами. Проблемы с привязкой сессий могут возникнуть, если клиент использует динамический IP. В ситуации, когда большое количество запросов проходит через один прокси-сервер, балансировку вряд ли можно назвать эффективной и справедливой. Описанные проблемы, однако, можно решить, используя cookies. 
